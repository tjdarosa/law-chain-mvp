# ERC-20 token scenario

The ERC-20 token smart contract demonstrates how to create and transfer fungible tokens using an account-based model. In an ERC-20 account-based model, there is an account for each participant that holds a balance of tokens.
A mint transaction creates tokens in an account, while a transfer transaction debits the caller's account and credits another account.

In this sample it is assumed that only one organization (played by CollectingOfficer) is in a central banker role and can mint new tokens into their account, while any organization can transfer tokens from their account to a recipient's account.
Accounts could be defined at the organization level or client identity level. In this sample accounts are defined at the client identity level, where every authorized client with an enrollment certificate from their organization implicitly has an account ID that matches their client ID.
The client ID is simply a base64-encoded concatenation of the issuer and subject from the client identity's enrollment certificate. The client ID can therefore be considered the account ID that is used as the payment address of a recipient.

In this tutorial, you will mint and transfer tokens as follows:

- A member of CollectingOfficer uses the `Mint` function to create new tokens into their account. The `Mint` smart contract function reads the certificate information of the client identity that submitted the transaction using the `GetClientIdentity.GetID()` API and credits the account associated with the client ID with the requested number of tokens.
- The same minter client will then use the `Transfer` function to transfer the requested number of tokens to the recipient's account. It is assumed that the recipient has provided their account ID to the transfer caller out of band. The recipient can then transfer tokens to other registered users in the same fashion.

## Bring up the test network

You can run the ERC-20 token transfer scenario using the Fabric test network. Open a command terminal and navigate to the test network directory in your local clone of the `fabric-samples`. We will operate from the `test-network` directory for the remainder of the tutorial.
```
cd fabric-samples/test-network
```

Run the following command to start the test network:
```
./network.sh up createChannel -ca
```

The test network is deployed with two peer organizations. The `createChannel` flag deploys the network with a single channel named `mychannel` with CollectingOfficer and EvidenceCustodian as channel members.
The -ca flag is used to deploy the network using certificate authorities. This allows you to use each organization's CA to register and enroll new users for this tutorial.

## Deploy the smart contract to the channel

You can use the test network script to deploy the ERC-20 token contract to the channel that was just created. Deploy the smart contract to `mychannel` using the following command:

**For a Go Contract:**
```
./network.sh deployCC -ccn token_erc20 -ccp ../token-erc-20/chaincode-go/ -ccl go
```

**For a Java Contract:**
```
./network.sh deployCC -ccn token_erc20 -ccp ../token-erc-20/chaincode-java/ -ccl java
```

**For a JavaScript Contract:**
```
./network.sh deployCC -ccn token_erc20 -ccp ../token-erc-20/chaincode-javascript/ -ccl javascript
```

The above commands deploys the chaincode with short name `token_erc20`. The smart contract will use the default endorsement policy of majority of channel members.
Since the channel has two members, this implies that we'll need to get peer endorsements from 2 out of the 2 channel members.

Now you are ready to call the deployed smart contract via peer CLI calls. But let's first create the client identities for our scenario.

## Register identities

The smart contract supports accounts owned by individual client identities from organizations that are members of the channel. In our scenario, the minter of the tokens will be a member of CollectingOfficer, while the recipient will belong to EvidenceCustodian. To highlight the connection between the `GetClientIdentity().GetID()` API and the information within a user's certificate, we will register two new identities using the CollectingOfficer and EvidenceCustodian Certificate Authorities (CA's), and then use the CA's to generate each identity's certificate and private key.

First, we need to set the following environment variables to use the Fabric CA client (and subsequent commands).
```
export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=$PWD/../config/
```

The terminal we have been using will represent CollectingOfficer. We will use the CollectingOfficer CA to create the minter identity. Set the Fabric CA client home to the MSP of the CollectingOfficer CA admin (this identity was generated by the test network script):
```
export FABRIC_CA_CLIENT_HOME=${PWD}/organizations/peerOrganizations/collectingofficer.example.com/
```

You can register a new minter client identity using the `fabric-ca-client` tool:
```
fabric-ca-client register --caname ca-collectingofficer --id.name minter --id.secret minterpw --id.type client --tls.certfiles "${PWD}/organizations/fabric-ca/collectingofficer/tls-cert.pem"
```

You can now generate the identity certificates and MSP folder by providing the minter's enroll name and secret to the enroll command:
```
fabric-ca-client enroll -u https://minter:minterpw@localhost:7054 --caname ca-collectingofficer -M "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/users/minter@collectingofficer.example.com/msp" --tls.certfiles "${PWD}/organizations/fabric-ca/collectingofficer/tls-cert.pem"
```

Run the command below to copy the Node OU configuration file into the minter identity MSP folder.
```
cp "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/msp/config.yaml" "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/users/minter@collectingofficer.example.com/msp/config.yaml"
```

Open a new terminal to represent EvidenceCustodian and navigate to fabric-samples/test-network. We'll use the EvidenceCustodian CA to create the EvidenceCustodian recipient identity. Set the Fabric CA client home to the MSP of the EvidenceCustodian CA admin:
```
cd fabric-samples/test-network
export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CA_CLIENT_HOME=${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/
```

You can register a recipient client identity using the `fabric-ca-client` tool:
```
fabric-ca-client register --caname ca-evidencecustodian --id.name recipient --id.secret recipientpw --id.type client --tls.certfiles "${PWD}/organizations/fabric-ca/evidencecustodian/tls-cert.pem"
```

We can now enroll to generate the recipient's identity certificates and MSP folder:
```
fabric-ca-client enroll -u https://recipient:recipientpw@localhost:8054 --caname ca-evidencecustodian -M "${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/users/recipient@evidencecustodian.example.com/msp" --tls.certfiles "${PWD}/organizations/fabric-ca/evidencecustodian/tls-cert.pem"
```

Run the command below to copy the Node OU configuration file into the recipient identity MSP folder.
```
cp "${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/msp/config.yaml" "${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/users/recipient@evidencecustodian.example.com/msp/config.yaml"
```

## Initialize the contract
Once we created the identity of the minter we can now initialize the contract.
Note that we need to call the initialize function before being able to use any functions of the contract. Initialize() can be called only once.

Shift back to the CollectingOfficer terminal, we'll set the following environment variables to operate the `peer` CLI as the minter identity from CollectingOfficer.
```
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID=CollectingOfficerMSP
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/collectingofficer.example.com/users/minter@collectingofficer.example.com/msp
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/collectingofficer.example.com/peers/peer0.collectingofficer.example.com/tls/ca.crt
export CORE_PEER_ADDRESS=localhost:7051
export TARGET_TLS_OPTIONS=(-o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/peers/peer0.collectingofficer.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/peers/peer0.evidencecustodian.example.com/tls/ca.crt")
```

The last environment variable above will be utilized within the CLI invoke commands to set the target peers for endorsement, and the target ordering service endpoint and TLS options.

We can then invoke the smart contract to initilize it
```
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Initialize","Args":["some name", "some symbol", "2"]}'
```

## Mint some tokens

Now that we have initialized the contract and created the identity of the minter, we can invoke the smart contract to mint some tokens.

We can then invoke the smart contract to mint 5000 tokens:
```
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Mint","Args":["5000"]}'
```

The mint function validated that the client is a member of the minter organization, and then credited the minter client's account with 5000 tokens. We can check the minter client's account balance by calling the `ClientAccountBalance` function.
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"ClientAccountBalance","Args":[]}'
```

The function queries the balance of the account associated with the minter client ID and returns:
```
5000
```

## Transfer tokens

The minter intends to transfer 100 tokens to the EvidenceCustodian recipient, but first the EvidenceCustodian recipient needs to provide their own account ID as the payment address.
A client can derive their account ID from their own public certificate, but to be sure the account ID is accurate, the contract has a `ClientAccountID` utility function that simply looks at the callers certificate and returns the calling client's ID, which will be used as the account ID.
Let's prepare the EvidenceCustodian terminal by setting the environment variables for the EvidenceCustodian recipient user.
```
export FABRIC_CFG_PATH=$PWD/../config/
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID=EvidenceCustodianMSP
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/users/recipient@evidencecustodian.example.com/msp
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/peers/peer0.evidencecustodian.example.com/tls/ca.crt
export CORE_PEER_ADDRESS=localhost:9051
```

Using the EvidenceCustodian terminal, the EvidenceCustodian recipient user can retrieve their own account ID:
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"ClientAccountID","Args":[]}'
```

**For a Go Contract:**

The function returns of recipient's account ID:
```
eDUwOTo6Q049cmVjaXBpZW50LE9VPWNsaWVudCxPPUh5cGVybGVkZ2VyLFNUPU5vcnRoIENhcm9saW5hLEM9VVM6OkNOPWNhLm9yZzIuZXhhbXBsZS5jb20sTz1vcmcyLmV4YW1wbGUuY29tLEw9SHVyc2xleSxTVD1IYW1wc2hpcmUsQz1VSw==
```

Let's base64 decode the account ID to make sure it represents the EvidenceCustodian recipient user:
```
echo eDUwOTo6Q049cmVjaXBpZW50LE9VPWNsaWVudCxPPUh5cGVybGVkZ2VyLFNUPU5vcnRoIENhcm9saW5hLEM9VVM6OkNOPWNhLm9yZzIuZXhhbXBsZS5jb20sTz1vcmcyLmV4YW1wbGUuY29tLEw9SHVyc2xleSxTVD1IYW1wc2hpcmUsQz1VSw== | base64 --decode
```

The result shows that the subject and issuer is indeed the recipient user from EvidenceCustodian:
```
x509::CN=recipient,OU=client,O=Hyperledger,ST=North Carolina,C=US::CN=ca.evidencecustodian.example.com,O=evidencecustodian.example.com,L=Hursley,ST=Hampshire,C=UK
```

**For a Java Contract**

The function returns of recipient's client ID.
```
x509::CN=recipient, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.evidencecustodian.example.com, O=evidencecustodian.example.com, L=Hursley, ST=Hampshire, C=UK
```

**For a JavaScript Contract:**

The function returns of recipient's client ID.
The result shows that the subject and issuer is indeed the recipient user from EvidenceCustodian:
```
x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=recipient::/C=UK/ST=Hampshire/L=Hursley/O=evidencecustodian.example.com/CN=ca.evidencecustodian.example.com
```

After the EvidenceCustodian recipient provides their account ID to the minter, the minter can initiate a transfer from their account to the recipient's account.
Back in the CollectingOfficer terminal, request the transfer of 100 tokens to the recipient account:

**For a Go Contract:**
```
export RECIPIENT="eDUwOTo6Q049cmVjaXBpZW50LE9VPWNsaWVudCxPPUh5cGVybGVkZ2VyLFNUPU5vcnRoIENhcm9saW5hLEM9VVM6OkNOPWNhLm9yZzIuZXhhbXBsZS5jb20sTz1vcmcyLmV4YW1wbGUuY29tLEw9SHVyc2xleSxTVD1IYW1wc2hpcmUsQz1VSw=="
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Transfer","Args":[ "'"$RECIPIENT"'","100"]}'
```
***For a Java Contract**
```
export RECIPIENT="x509::CN=recipient, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.evidencecustodian.example.com, O=evidencecustodian.example.com, L=Hursley, ST=Hampshire, C=UK"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Transfer","Args":[ "'"$RECIPIENT"'","100"]}'
```

**For a JavaScript Contract:**
```
export RECIPIENT="x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=recipient::/C=UK/ST=Hampshire/L=Hursley/O=evidencecustodian.example.com/CN=ca.evidencecustodian.example.com"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Transfer","Args":[ "'"$RECIPIENT"'","100"]}'
```

The `Transfer` function validates that the account associated with the calling client ID has sufficient funds for the transfer.
It will then debit the caller's account and credit the recipient's account. Note that the sample contract will automatically create an account with zero balance for the recipient, if one does not yet exist.

While still in the CollectingOfficer terminal, let's request the minter's account balance again:
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"ClientAccountBalance","Args":[]}'
```

The function queries the balance of the account associated with the minter client ID and returns:
```
4900
```

And then using the EvidenceCustodian terminal, let's request the recipient's balance:
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"ClientAccountBalance","Args":[]}'
```

The function queries the balance of the account associated with the recipient client ID and returns:
```
100
```

Congratulations, you've transferred 100 tokens! The EvidenceCustodian recipient can now transfer tokens to other registered users in the same manner.

## 3rd party transfers (TransferFrom)

This sample has another ERC-20 transfer method called `TransferFrom`, which allows an approved 3rd party spender to transfer fungible tokens on behalf of the account owner. This scenario demonstrates how to approve the spender and transfer fungible tokens.

In this scenario, you will approve the spender and transfer tokens as follows:

- A minter has already created tokens according to the scenario above.
- The same minter client uses the `Approve` function to set the allowance of tokens a spender client can transfer on behalf of the minter. It is assumed that the spender has provided their client ID to the `Approve` caller out of band.
- The spender client will then use the `TransferFrom` function to transfer the requested number of tokens to the recipient's account on behalf of the minter. It is assumed that the recipient has provided their client ID to the `TransferFrom` caller out of band.

## Register identity for 3rd party spender

You have already brought up the network and deployed the smart contract to the channel. We will use the same network and smart contract.

We will use the CollectingOfficer CA to create the spender identity.
Back in the CollectingOfficer terminal, you can register a new spender client identity using the `fabric-ca-client` tool:
```
fabric-ca-client register --caname ca-collectingofficer --id.name spender --id.secret spenderpw --id.type client --tls.certfiles "${PWD}/organizations/fabric-ca/collectingofficer/tls-cert.pem"
```

You can now generate the identity certificates and MSP folder by providing the spender's enroll name and secret to the enroll command:
```
fabric-ca-client enroll -u https://spender:spenderpw@localhost:7054 --caname ca-collectingofficer -M "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/users/spender@collectingofficer.example.com/msp" --tls.certfiles "${PWD}/organizations/fabric-ca/collectingofficer/tls-cert.pem"
```

Run the command below to copy the Node OU configuration file into the spender identity MSP folder.
```
cp "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/msp/config.yaml" "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/users/spender@collectingofficer.example.com/msp/config.yaml"
```

## Approve a spender

The minter intends to approve 500 tokens to be transferred by the spender, but first the spender needs to provide their own client ID as the payment address.

Open a 3rd terminal to represent the spender in CollectingOfficer and navigate to fabric-samples/test-network. Set the environment variables for the CollectingOfficer spender user.

```
export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=$PWD/../config/
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID=CollectingOfficerMSP
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/collectingofficer.example.com/users/spender@collectingofficer.example.com/msp
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/collectingofficer.example.com/peers/peer0.collectingofficer.example.com/tls/ca.crt
export CORE_PEER_ADDRESS=localhost:7051
export TARGET_TLS_OPTIONS=(-o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/collectingofficer.example.com/peers/peer0.collectingofficer.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/evidencecustodian.example.com/peers/peer0.evidencecustodian.example.com/tls/ca.crt")
```

Now the CollectingOfficer spender can retrieve their own client ID:
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"ClientAccountID","Args":[]}'
```

**For a Go Contract:**

The function returns of spender's account ID:
```
eDUwOTo6Q049c3BlbmRlcixPVT1jbGllbnQsTz1IeXBlcmxlZGdlcixTVD1Ob3J0aCBDYXJvbGluYSxDPVVTOjpDTj1jYS5vcmcxLmV4YW1wbGUuY29tLE89b3JnMS5leGFtcGxlLmNvbSxMPUR1cmhhbSxTVD1Ob3J0aCBDYXJvbGluYSxDPVVT
```

**For a Java Contract**

The function returns of spenders's client ID.
```
x509::CN=spender, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.collectingofficer.example.com, O=collectingofficer.example.com, L=Durham, ST=North Carolina, C=US
```

**For a JavaScript Contract:**

The function returns of spender's client ID.
The result shows that the subject and issuer is indeed the recipient user from EvidenceCustodian:
```
x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=spender::/C=US/ST=North Carolina/L=Durham/O=collectingofficer.example.com/CN=ca.collectingofficer.example.com
```

After the CollectingOfficer spender provides their client ID to the minter, the minter can approve a spender.
Back in the CollectingOfficer minter terminal, request the approval of 500 tokens to be withdrawn by the spender.

**For a Go Contract:**

```
export SPENDER="eDUwOTo6Q049c3BlbmRlcixPVT1jbGllbnQsTz1IeXBlcmxlZGdlcixTVD1Ob3J0aCBDYXJvbGluYSxDPVVTOjpDTj1jYS5vcmcxLmV4YW1wbGUuY29tLE89b3JnMS5leGFtcGxlLmNvbSxMPUR1cmhhbSxTVD1Ob3J0aCBDYXJvbGluYSxDPVVT"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Approve","Args":[ "'"$SPENDER"'","500"]}'
```

**For a Java Contract:**

```
export SPENDER="x509::CN=spender, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.collectingofficer.example.com, O=collectingofficer.example.com, L=Durham, ST=North Carolina, C=US"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Approve","Args":["'"$SPENDER"'", "500"]}'
```

**For a JavaScript Contract:**

```
export SPENDER="x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=spender::/C=US/ST=North Carolina/L=Durham/O=collectingofficer.example.com/CN=ca.collectingofficer.example.com"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"Approve","Args":["'"$SPENDER"'", "500"]}'
```

The approve function specified that the spender client can transfer 500 tokens on behalf of the minter. We can check the spender client's allowance from the minter by calling the `allowance` function.

Let's request the spender's allowance from the CollectingOfficer minter terminal.

**For a Go Contract:**

```
export MINTER="eDUwOTo6Q049bWludGVyLE9VPWNsaWVudCxPPUh5cGVybGVkZ2VyLFNUPU5vcnRoIENhcm9saW5hLEM9VVM6OkNOPWNhLm9yZzEuZXhhbXBsZS5jb20sTz1vcmcxLmV4YW1wbGUuY29tLEw9RHVyaGFtLFNUPU5vcnRoIENhcm9saW5hLEM9VVM="
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"Allowance","Args":["'"$MINTER"'", "'"$SPENDER"'"]}'
```

**For a Java Contract:**

```
export MINTER="x509::CN=minter, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.collectingofficer.example.com, O=collectingofficer.example.com, L=Durham, ST=North Carolina, C=US"
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"Allowance","Args":["'"$MINTER"'", "'"$SPENDER"'"]}'
```

**For a JavaScript Contract:**

```
export MINTER="x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=minter::/C=US/ST=North Carolina/L=Durham/O=collectingofficer.example.com/CN=ca.collectingofficer.example.com"
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"Allowance","Args":["'"$MINTER"'", "'"$SPENDER"'"]}'
```

The function queries the allowance associated with the spender client ID and returns:
```
500
```

## TransferFrom tokens

The spender intends to transfer 100 tokens to the EvidenceCustodian recipient on behalf of the minter. The spender has already got the minter client Id and the recipient client ID.

Back in the 3rd terminal, request the transfer of 100 tokens to the recipient account.

**For a Go Contract:**

```
export MINTER="eDUwOTo6Q049bWludGVyLE9VPWNsaWVudCxPPUh5cGVybGVkZ2VyLFNUPU5vcnRoIENhcm9saW5hLEM9VVM6OkNOPWNhLm9yZzEuZXhhbXBsZS5jb20sTz1vcmcxLmV4YW1wbGUuY29tLEw9RHVyaGFtLFNUPU5vcnRoIENhcm9saW5hLEM9VVM="
export RECIPIENT="eDUwOTo6Q049cmVjaXBpZW50LE9VPWNsaWVudCxPPUh5cGVybGVkZ2VyLFNUPU5vcnRoIENhcm9saW5hLEM9VVM6OkNOPWNhLm9yZzIuZXhhbXBsZS5jb20sTz1vcmcyLmV4YW1wbGUuY29tLEw9SHVyc2xleSxTVD1IYW1wc2hpcmUsQz1VSw=="
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"TransferFrom","Args":[ "'"$MINTER"'", "'"$RECIPIENT"'", "100"]}'
```

**For a Java Contract:**

```
export MINTER="x509::CN=minter, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.collectingofficer.example.com, O=collectingofficer.example.com, L=Durham, ST=North Carolina, C=US"
export RECIPIENT="x509::CN=recipient, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.evidencecustodian.example.com, O=evidencecustodian.example.com, L=Hursley, ST=Hampshire, C=UK"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"TransferFrom","Args":[ "'"$MINTER"'", "'"$RECIPIENT"'", "100"]}'
```

**For a JavaScript Contract:**

```
export MINTER="x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=minter::/C=US/ST=North Carolina/L=Durham/O=collectingofficer.example.com/CN=ca.collectingofficer.example.com"
export RECIPIENT="x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=recipient::/C=UK/ST=Hampshire/L=Hursley/O=evidencecustodian.example.com/CN=ca.evidencecustodian.example.com"
peer chaincode invoke "${TARGET_TLS_OPTIONS[@]}" -C mychannel -n token_erc20 -c '{"function":"TransferFrom","Args":[ "'"$MINTER"'", "'"$RECIPIENT"'", "100"]}'
```

The `TransferFrom` function has three args: sender, recipient, amount. The function validates that the account associated with the sender has sufficient funds for the transfer. The function also validates if the allowance associated with the calling client ID exceeds funds to be transferred.
It will then debit the sender's account and credit the recipient's account. It will also decrease the spender's allowance approved by the minter. Note that the sample contract will automatically create an account with zero balance for the recipient, if one does not yet exist.

While still in the 3rd terminal for the spender, let's request the minter's account balance again:
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"BalanceOf","Args":["'"$MINTER"'"]}'
```

The function queries the balance of the account associated with the minter client ID and returns:
```
4800
```

While still in the 3rd terminal for the spender, let's request the spender's allowance from the minter again.

**For a Go Contract:**

```
export SPENDER="eDUwOTo6Q049c3BlbmRlcixPVT1jbGllbnQsTz1IeXBlcmxlZGdlcixTVD1Ob3J0aCBDYXJvbGluYSxDPVVTOjpDTj1jYS5vcmcxLmV4YW1wbGUuY29tLE89b3JnMS5leGFtcGxlLmNvbSxMPUR1cmhhbSxTVD1Ob3J0aCBDYXJvbGluYSxDPVVT"
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"Allowance","Args":["'"$MINTER"'", "'"$SPENDER"'"]}'
```

**For a Java Contract:**

```
export SPENDER="x509::CN=spender, OU=client, O=Hyperledger, ST=North Carolina, C=US::CN=ca.collectingofficer.example.com, O=collectingofficer.example.com, L=Durham, ST=North Carolina, C=US"
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"Allowance","Args":["'"$MINTER"'", "'"$SPENDER"'"]}'
```

**For a JavaScript Contract:**

```
export SPENDER="x509::/C=US/ST=North Carolina/O=Hyperledger/OU=client/CN=spender::/C=US/ST=North Carolina/L=Durham/O=collectingofficer.example.com/CN=ca.collectingofficer.example.com"
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"Allowance","Args":["'"$MINTER"'", "'"$SPENDER"'"]}'
```

The function queries the allowance associated with the spender client ID and returns:
```
400
```

And then using the EvidenceCustodian terminal, let's request the recipient's balance:
```
peer chaincode query -C mychannel -n token_erc20 -c '{"function":"ClientAccountBalance","Args":[]}'
```

The function queries the balance of the account associated with the recipient client ID and returns:
```
200
```

Congratulations, you've transferred 100 tokens! The EvidenceCustodian recipient can now transfer tokens to other registered users in the same manner.

## Clean up

When you are finished, you can bring down the test network. The command will remove all the nodes of the test network, and delete any ledger data that you created:
```
./network.sh down
```

## Contract extension ideas

You can extend the basic ERC-20 account-based token sample to meet other requirements. For example:

* Rather than using the default 'majority' endorsement policy, you could set the endorsement policy to a subset of organizations that represent trust anchors for the contract execution.
* You could also require that accounts get setup before use, and apply state-based endorsement for each account key that has been created. For example on an CollectingOfficer account, set state-based endorsement policy to be CollectingOfficer and the central banker (or some other trust anchor). And on an EvidenceCustodian account, set state-based endorsement policy to be EvidenceCustodian and the central banker (or some other trust anchor). Then to transfer tokens from an CollectingOfficer account to an EvidenceCustodian account, you would require endorsements from CollectingOfficer, EvidenceCustodian, and the central banker (or some other trust anchor).
* You could utilize anonymous addresses for accounts based on private-public key pairs, instead of accounts keyed by the client ID. In order to spend the tokens, the client would have to sign the transfer input as proof that they own the address private key, which the contract would then validate, similar to the Ethereum model in the permissionless blockchain space. However, in a permissioned blockchain such as Fabric, only registered clients are authorized to participate. Furthermore, if you don't want to leak the registered client identity associated with each account, the clients could be registered using an Identity Mixer MSP, so that the client itself is also anonymous in each of the token transactions.
